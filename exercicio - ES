package javaapplication5;

/**
 *
 * @author 31409695
 */
public class JavaApplication5 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int[] tmp, k10, k50, k100, k500, k1000;
        k10 = inicializaVetore(10000);
        k50 = inicializaVetore(50000);
        k100 = inicializaVetore(100000);
        k500 = inicializaVetore(500000);
        k1000 = inicializaVetore(1000000);

        tmp = k500.clone();
        System.out.println("500000 posições\n");

        long inicio = System.currentTimeMillis();
        quickSort(tmp, 0, tmp.length - 1);
        long fim = System.currentTimeMillis();
        long tempo = fim - inicio;
        System.out.println("Tempo quickSort 500000: " + tempo + "\n");        

        tmp = k500.clone();

        inicio = System.currentTimeMillis();
        insertionSort(tmp);
        fim = System.currentTimeMillis();
        tempo = fim - inicio;
        System.out.println("Tempo insertionSort 500000: " + tempo + "\n");
        
        tmp = k500.clone();

        inicio = System.currentTimeMillis();
        mergesort(tmp, 0, tmp.length);
        fim = System.currentTimeMillis();
        tempo = fim - inicio;
        System.out.println("Tempo mergeSort 500000: " + tempo + "\n");
        
        tmp = k500.clone();

        inicio = System.currentTimeMillis();
        bubbleSort(tmp, tmp.length);
        fim = System.currentTimeMillis();
        tempo = fim - inicio;
        System.out.println("Tempo bubbleSort 500000: " + tempo + "\n");
        
        /*
         inicio = System.currentTimeMillis();
         quickSort(tmp, tmp.length);
         fim = System.currentTimeMillis();
         tempo = fim - inicio;
         System.out.println("Tempo 50000: " + tempo);
        
         tmp = k100.clone();
        
         inicio = System.currentTimeMillis();
         quickSort(tmp, tmp.length);
         fim = System.currentTimeMillis();
         tempo = fim - inicio;
         System.out.println("Tempo 100000: " + tempo);
        
         tmp = k500.clone();
        
         inicio = System.currentTimeMillis();
         quickSort(tmp, tmp.length);
         fim = System.currentTimeMillis();
         tempo = fim - inicio;
         System.out.println("Tempo 500000: " + tempo);
        
         tmp = k1000.clone();
        
         inicio = System.currentTimeMillis();
         quickSort(tmp, tmp.length);
         fim = System.currentTimeMillis();
         tempo = fim - inicio;
         System.out.println("Tempo 1000000: " + tempo);*/
    }

    static int[] inicializaVetore(int size) {
        int[] v = new int[size];
        for (int i = 0; i < v.length; i++) {
            v[i] = (int) (Math.random() * 10000);
        }
        return v;
    }

    public static void bubbleSort(int[] chave, int n) {
        int temp;
// inicia o Bubble Sort
        for (int i = 0; i < n; i++) {
            for (int j = 1; j < n - i; j++) {
                if (chave[j - 1] > chave[j]) {
//troca os elementos
                    temp = chave[j - 1];
                    chave[j - 1] = chave[j];
                    chave[j] = temp;
                }
            }
        }
    }

    static void insertionSort(int[] vetor) {
        int j, aux;
        for (int i = 1; i < vetor.length; i++) {
            aux = vetor[i];
            for (j = i - 1; j >= 0 && aux < vetor[j]; j--) {
                vetor[j + 1] = vetor[j];
            }
            vetor[j + 1] = aux;
        }
    }

    static int separa(int[] vetor, int ini, int fim) {
        int pivo, esq;
        pivo = vetor[ini];
        esq = 0;
        while (ini < fim) {
            if (esq == 0) {
                if (pivo >= vetor[fim]) {
                    vetor[ini] = vetor[fim];
                    ini++;
                    esq = 1;
                } else {
                    fim--;
                }
            } else if (pivo < vetor[ini]) {
                vetor[fim] = vetor[ini];
                fim--;
                esq = 0;
            } else {
                ini++;
            }
        }
        vetor[fim] = pivo;
        return fim;
    }

    static void quickSort(int[] vetor, int ini, int fim) {
        int k;
        if (fim > ini) {
            k = separa(vetor, ini, fim);
            quickSort(vetor, ini, k - 1);
            quickSort(vetor, k + 1, fim);
        }
    }

    public static void mergesort(int[] data, int first, int n) {
        int n1; // Tamanho da primeira metade do vetor
        int n2; // Tamanho da segunda metade do vetor
        if (n > 1) {
// Calcula o tamanho das duas metades
            n1 = n / 2;
            n2 = n - n1;
// ordena data[first] até data[first+n1-1]
            mergesort(data, first, n1);
// ordena data[first+n1] até o final
            mergesort(data, first + n1, n2);
// mescla as duas metades ordenadas
            merge(data, first, n1, n2);
        }
    }

    private static void merge(int[] data, int first, int n1, int n2) {
        int[] temp = new int[n1 + n2]; // Cria o vetor temporário
// Nro de elementos copiados do vetor data para o vetor temp
        int copied = 0;
// Nro de elementos copiados da primeira metade do vetor data
        int copied1 = 0;
// Nro de elementos copiados da segunda metade do vetor data
        int copied2 = 0;
// Índice p/ copiar elementos do vetor temp p/ o vetor data
        int i;
// Mescla os elementos, copiando das duas metades do vetor
// data para o vetor temporário.
        while ((copied1 < n1) && (copied2 < n2)) {
            if (data[first + copied1] < data[first + n1 + copied2]) {
                temp[copied++] = data[first + (copied1++)];
            } else {
                temp[copied++] = data[first + n1 + (copied2++)];
            }
        }
    }

}
